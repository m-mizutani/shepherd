// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/m-mizutani/shepherd/pkg/domain/interfaces"
	"github.com/m-mizutani/shepherd/pkg/domain/model"
	"sync"
)

// Ensure, that PackageDetectorUseCaseMock does implement interfaces.PackageDetectorUseCase.
// If this is not the case, regenerate this file with moq.
var _ interfaces.PackageDetectorUseCase = &PackageDetectorUseCaseMock{}

// PackageDetectorUseCaseMock is a mock implementation of interfaces.PackageDetectorUseCase.
//
//	func TestSomethingThatUsesPackageDetectorUseCase(t *testing.T) {
//
//		// make and configure a mocked interfaces.PackageDetectorUseCase
//		mockedPackageDetectorUseCase := &PackageDetectorUseCaseMock{
//			DetectFromPRInfoFunc: func(ctx context.Context, prInfo *model.PRInfo) (*model.PackageUpdateDetection, error) {
//				panic("mock out the DetectFromPRInfo method")
//			},
//			DetectPackageUpdateFunc: func(ctx context.Context, event *model.WebhookEvent) error {
//				panic("mock out the DetectPackageUpdate method")
//			},
//			ExtractPackageVersionSourcesFunc: func(ctx context.Context, detection *model.PackageUpdateDetection, prInfo *model.PRInfo) error {
//				panic("mock out the ExtractPackageVersionSources method")
//			},
//		}
//
//		// use mockedPackageDetectorUseCase in code that requires interfaces.PackageDetectorUseCase
//		// and then make assertions.
//
//	}
type PackageDetectorUseCaseMock struct {
	// DetectFromPRInfoFunc mocks the DetectFromPRInfo method.
	DetectFromPRInfoFunc func(ctx context.Context, prInfo *model.PRInfo) (*model.PackageUpdateDetection, error)

	// DetectPackageUpdateFunc mocks the DetectPackageUpdate method.
	DetectPackageUpdateFunc func(ctx context.Context, event *model.WebhookEvent) error

	// ExtractPackageVersionSourcesFunc mocks the ExtractPackageVersionSources method.
	ExtractPackageVersionSourcesFunc func(ctx context.Context, detection *model.PackageUpdateDetection, prInfo *model.PRInfo) error

	// calls tracks calls to the methods.
	calls struct {
		// DetectFromPRInfo holds details about calls to the DetectFromPRInfo method.
		DetectFromPRInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// PrInfo is the prInfo argument value.
			PrInfo *model.PRInfo
		}
		// DetectPackageUpdate holds details about calls to the DetectPackageUpdate method.
		DetectPackageUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Event is the event argument value.
			Event *model.WebhookEvent
		}
		// ExtractPackageVersionSources holds details about calls to the ExtractPackageVersionSources method.
		ExtractPackageVersionSources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Detection is the detection argument value.
			Detection *model.PackageUpdateDetection
			// PrInfo is the prInfo argument value.
			PrInfo *model.PRInfo
		}
	}
	lockDetectFromPRInfo             sync.RWMutex
	lockDetectPackageUpdate          sync.RWMutex
	lockExtractPackageVersionSources sync.RWMutex
}

// DetectFromPRInfo calls DetectFromPRInfoFunc.
func (mock *PackageDetectorUseCaseMock) DetectFromPRInfo(ctx context.Context, prInfo *model.PRInfo) (*model.PackageUpdateDetection, error) {
	if mock.DetectFromPRInfoFunc == nil {
		panic("PackageDetectorUseCaseMock.DetectFromPRInfoFunc: method is nil but PackageDetectorUseCase.DetectFromPRInfo was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		PrInfo *model.PRInfo
	}{
		Ctx:    ctx,
		PrInfo: prInfo,
	}
	mock.lockDetectFromPRInfo.Lock()
	mock.calls.DetectFromPRInfo = append(mock.calls.DetectFromPRInfo, callInfo)
	mock.lockDetectFromPRInfo.Unlock()
	return mock.DetectFromPRInfoFunc(ctx, prInfo)
}

// DetectFromPRInfoCalls gets all the calls that were made to DetectFromPRInfo.
// Check the length with:
//
//	len(mockedPackageDetectorUseCase.DetectFromPRInfoCalls())
func (mock *PackageDetectorUseCaseMock) DetectFromPRInfoCalls() []struct {
	Ctx    context.Context
	PrInfo *model.PRInfo
} {
	var calls []struct {
		Ctx    context.Context
		PrInfo *model.PRInfo
	}
	mock.lockDetectFromPRInfo.RLock()
	calls = mock.calls.DetectFromPRInfo
	mock.lockDetectFromPRInfo.RUnlock()
	return calls
}

// DetectPackageUpdate calls DetectPackageUpdateFunc.
func (mock *PackageDetectorUseCaseMock) DetectPackageUpdate(ctx context.Context, event *model.WebhookEvent) error {
	if mock.DetectPackageUpdateFunc == nil {
		panic("PackageDetectorUseCaseMock.DetectPackageUpdateFunc: method is nil but PackageDetectorUseCase.DetectPackageUpdate was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Event *model.WebhookEvent
	}{
		Ctx:   ctx,
		Event: event,
	}
	mock.lockDetectPackageUpdate.Lock()
	mock.calls.DetectPackageUpdate = append(mock.calls.DetectPackageUpdate, callInfo)
	mock.lockDetectPackageUpdate.Unlock()
	return mock.DetectPackageUpdateFunc(ctx, event)
}

// DetectPackageUpdateCalls gets all the calls that were made to DetectPackageUpdate.
// Check the length with:
//
//	len(mockedPackageDetectorUseCase.DetectPackageUpdateCalls())
func (mock *PackageDetectorUseCaseMock) DetectPackageUpdateCalls() []struct {
	Ctx   context.Context
	Event *model.WebhookEvent
} {
	var calls []struct {
		Ctx   context.Context
		Event *model.WebhookEvent
	}
	mock.lockDetectPackageUpdate.RLock()
	calls = mock.calls.DetectPackageUpdate
	mock.lockDetectPackageUpdate.RUnlock()
	return calls
}

// ExtractPackageVersionSources calls ExtractPackageVersionSourcesFunc.
func (mock *PackageDetectorUseCaseMock) ExtractPackageVersionSources(ctx context.Context, detection *model.PackageUpdateDetection, prInfo *model.PRInfo) error {
	if mock.ExtractPackageVersionSourcesFunc == nil {
		panic("PackageDetectorUseCaseMock.ExtractPackageVersionSourcesFunc: method is nil but PackageDetectorUseCase.ExtractPackageVersionSources was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Detection *model.PackageUpdateDetection
		PrInfo    *model.PRInfo
	}{
		Ctx:       ctx,
		Detection: detection,
		PrInfo:    prInfo,
	}
	mock.lockExtractPackageVersionSources.Lock()
	mock.calls.ExtractPackageVersionSources = append(mock.calls.ExtractPackageVersionSources, callInfo)
	mock.lockExtractPackageVersionSources.Unlock()
	return mock.ExtractPackageVersionSourcesFunc(ctx, detection, prInfo)
}

// ExtractPackageVersionSourcesCalls gets all the calls that were made to ExtractPackageVersionSources.
// Check the length with:
//
//	len(mockedPackageDetectorUseCase.ExtractPackageVersionSourcesCalls())
func (mock *PackageDetectorUseCaseMock) ExtractPackageVersionSourcesCalls() []struct {
	Ctx       context.Context
	Detection *model.PackageUpdateDetection
	PrInfo    *model.PRInfo
} {
	var calls []struct {
		Ctx       context.Context
		Detection *model.PackageUpdateDetection
		PrInfo    *model.PRInfo
	}
	mock.lockExtractPackageVersionSources.RLock()
	calls = mock.calls.ExtractPackageVersionSources
	mock.lockExtractPackageVersionSources.RUnlock()
	return calls
}
